### 1、spring的事务传播以及应用场景：

> 事务传播机制的应用场景：事务的嵌套，
> 事务嵌套的出现则是由于总有一些表是公用的，所以在service层中出现相互调用的问题，于是事务嵌套则出现了，解决方案：spring的事务传播机制

#### 1.1 spring事务传播机制：
术语约定：
```java
ServiceA.methodA(){
    ServiceB.methodB()
}
```
##### 1.1.1 PROPAGATION_REQUIRED

spring默认的事务传播机制，如果当前方法已经创建事务，那么则支持当前事务(即加入到当前事务)如果当前没有事务则创建新的事务。简而言之：即要成功一起成功，否则则一起回滚，无论是内层事务发生异常，还是外层事务发生异常，都将发生回滚

##### 1.1.2 PROPAGATION_SUPPORTS

支持当前事务，如果当前没有事务则以非事务的方式执行

##### 1.1.3 PROPAGATION_MANDATORY

如果当前存在事务则使用当前事务否则则抛出异常

##### 1.1.4 PROPAGATION_REQUIRED_NEW

新建事务，如果当前存在事务则挂起当前事务，当事务提交后，外层的事务开始执行，当内存事务的异常回滚，外层事务是不会受到影响的

##### 1.1.5 PROPAGATION_NESTED

如果当前存在事务，则在嵌套事务内执行，属于外层事务的子事务，外层事务提交，内层事务才可以提交，外层的事务的回滚内存事务也会发生回滚

##### 1.1.6 ReadOnly

严格的来说这不算是spring的事务的传播机制，但是这个注解会告诉数据源这是一个只读事务只读事务会有一定的速度优化，其他的方法则使用默认PROPAGATION_REQUIRED这种默认的机制

#### 1.2 spring事务传播机制的应用的场景：

- PROPAGATION_REQUIRED 

这个是spring默认的事务传播机制，我们通常也是使用的这种，比如说我们外层事务依赖内层事务的结果，单同时这两个事务要么必须成功要么必须失败则就需要使用这种事务传播机制

-PROPAGATION_REQUIRED_NEW

这个是无论外层ui


