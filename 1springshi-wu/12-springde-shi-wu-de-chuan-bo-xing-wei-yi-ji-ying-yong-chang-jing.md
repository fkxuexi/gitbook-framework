### 1、spring的事务传播以及应用场景：

> 事务传播机制的应用场景：事务的嵌套，
> 事务嵌套的出现则是由于总有一些表是公用的，所以在service层中出现相互调用的问题，于是事务嵌套则出现了，解决方案：spring的事务传播机制

#### 1.1 spring事务传播机制：

术语约定：

```java
ServiceA.methodA(){
    ServiceB.methodB()
}
```

则我们 称methodA为外层，methodB则为内层

##### 1.1.1 PROPAGATION_REQUIRED

spring默认的事务传播机制，如果当前方法已经创建事务，那么则支持当前事务(即加入到当前事务)如果当前没有事务则创建新的事务。简而言之：即要成功一起成功，否则则一起回滚，无论是内层事务发生异常，还是外层事务发生异常，都将发生回滚

##### 1.1.2 PROPAGATION_REQUIRES_NEW

新建内层事务，当内层事务被调用是，外层事务被挂起，内层事务相对于外层事务完全独立，有独立的隔离性

##### 1.1.3 PROPAGATION_SUPPORTS

支持当前事务，如果当前没有事务则以非事务的方式执行

##### 1.1.4 PROPAGATION_MANDATORY

如果当前存在事务则使用当前事务否则则抛出异常

##### 1.1.5 PROPAGATION_NESTED

如果当前存在事务，则在嵌套事务内执行，属于外层事务的子事务，外层事务提交，内层事务才可以提交，外层的事务的回滚内存事务也会发生回滚

##### 1.1.6 ReadOnly

严格的来说这不算是spring的事务的传播机制，但是这个注解会告诉数据源这是一个只读事务只读事务会有一定的速度优化，其他的方法则使用默认PROPAGATION_REQUIRED这种默认的机制

#### 1.2 spring事务传播机制的应用的场景：

- PROPAGATION_REQUIRED 

这个是spring默认的事务传播机制，我们通常也是使用的这种，比如说我们外层事务依赖内层事务的结果，单同时这两个事务要么必须成功要么必须失败则就需要使用这种事务传播机制

-PROPAGATION_REQUIRES_NEW

内层事务和外层是独立的两个事务，外层事务异常回滚不会影响到内层的事务，但是内层的事务的异常回滚会影响到外层事务

ps：做测试的时候，异常的位置需要放对，别你放到中间，异常一跑内外层都不能执行成功




